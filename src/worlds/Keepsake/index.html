<html>
<head>
    <!--TESTING COMMENT BY STEVEN-->
  <!-- Circles' head scripts [REQUIRED] -->
  <circles-start-scripts/>
  <!-- custom scripts are added here-->
  <script src="/worlds/Keepsake/components/circles-pickup-object.js"></script>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keepsake</title>
  <!-- scripts link -->

  <!-- css link -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/user-gesture.css">
    <!-- INTERACTIVITY SCRIPT HERE ******************************************************************************* -->
    <script>
      "use strict";

    // custom pick up
    AFRAME.registerComponent('pickupable', {
    init: function() {
        var self = this;
        self.player = document.querySelector('#camera');
        self.pickedUp = false;
        self.clickDebounce = false; // click debounce
        
        self.playerHolder = CIRCLES.getAvatarHolderElementBody();
        self.origParent = self.el.parentNode;
        
        if (!self.el.classList.contains('interactive')) {
        self.el.classList.add('interactive'); 
        }
        
        // event handler to stop default Circles control
        self.suppressControlsFunc = function(e) {
        // stop circles object-pickup UI from showing
        e.stopPropagation();
        // preventing default behaviours
        e.preventDefault();
        return false;
        };

        // debounce
        self.handleClick = function(e) {
        if (self.clickDebounce) return;
        
        self.clickDebounce = true;
        setTimeout(function() { self.clickDebounce = false; }, 300); // 300ms debounce
        
        console.log('clicked on object, current state:', self.pickedUp ? 'picked up' : 'not picked up');
        
        if (self.pickedUp === true) {
            // release obj
            self.origParent.object3D.attach(self.el.object3D);
            console.log('released');
            self.pickedUp = false;
            
            self.el.emit('object-released', {id: self.el.id}, true);
            self.el.sceneEl.emit('object-released', {id: self.el.id}, false);
        } else {            
            // pick up obj
            self.playerHolder.object3D.attach(self.el.object3D);
            
            // position in front of camera
            self.el.setAttribute('position', {
            x: 0.8,
            y: -0.6,  // slightly below center of view
            z: 1     // closer to camera so it appears in hand
            });
            
            self.el.setAttribute('rotation', {
            x: 0,
            y: 0,
            z: 0
            });
            
            console.log('picked up');
            self.pickedUp = true;
            self.el.emit('object-picked-up', {id: self.el.id}, true);
            self.el.sceneEl.emit('object-picked-up', {id: self.el.id}, false);
        }
        };

        self.el.addEventListener('click', self.handleClick);
        
        // is obj picked up
        self.isPickedUp = function() {
        return self.pickedUp;
        };
    },
    
    remove: function() {
        this.el.removeEventListener('click', this.handleClick);
    }
    });

    // orb placement and gallery naming
    AFRAME.registerComponent('plate-interaction', {
    init: function() {
      const self = this;
      self.hasObject = false;
      self.placedObjectId = null;
      self.objectsLabeled = {}; // track labelled objs
      
      if (!self.el.classList.contains('interactive')) {
        self.el.classList.add('interactive');
      }
      
      self.plateTopPosition = new THREE.Vector3();
      self.updatePlatePosition = () => {
        self.el.object3D.getWorldPosition(self.plateTopPosition);
        self.plateTopPosition.y += (self.el.getAttribute('height') || 0.1) / 2 + 0.05;
      };
      
      self.el.addEventListener('click', () => {
        console.log('Plate clicked');
        const manager = self.el.sceneEl.components['interaction-manager'];
        const heldObjectId = manager.pickedUpObject;
        
        console.log('Manager reports held object:', heldObjectId);
        
        // If nothing held, do nothing
        if (!heldObjectId) {
          console.log('Nothing in hand to place');
          return;
        }
        
        const heldObject = document.getElementById(heldObjectId);
        if (!heldObject) {
          console.log('Could not find object with ID:', heldObjectId);
          return;
        }
        
        self.updatePlatePosition();
        
        console.log('Placing object on plate:', heldObjectId);
        self.placedObjectId = heldObjectId;
        self.hasObject = true;
        
        // detach from player and place on plate
        heldObject.sceneEl.object3D.attach(heldObject.object3D);
        
        // set pos on plate
        heldObject.setAttribute('position', {
          x: self.plateTopPosition.x,
          y: self.plateTopPosition.y,
          z: self.plateTopPosition.z
        });
        
        heldObject.setAttribute('rotation', '0 0 0');
        
        if (heldObject.components['pickupable']) {
          heldObject.components['pickupable'].pickedUp = false;
        }
        
        manager.pickedUpObject = null;
        
        // only show labelling if there isn't a label
        if (!self.objectsLabeled[heldObjectId]) {
          const labelUI = document.querySelector('#label-ui');
          if (labelUI) {
            labelUI.style.display = 'block';
            
            labelUI.dataset.objectId = heldObjectId;
            
            const labelInput = document.querySelector('#label-input');
            if (labelInput) {
              labelInput.value = '';
              setTimeout(() => labelInput.focus(), 100);
            }
          }
          else
          {
            window.location.href = "gallery.html";
          }
        }
      });
      
      self.updatePlatePosition();
    }
  });

    // Gallery Naming
    AFRAME.registerComponent('object-label', {
    schema: {
        text: {type: 'string', default: ''},
        color: {type: 'color', default: '#FFF'},
        size: {type: 'number', default: 1.0},
        yOffset: {type: 'number', default: 0.3} // distance above object
    },
    
    init: function() {
        this.createLabel();
    },
    
    update: function() {
        this.createLabel();
    },
    
    createLabel: function() {
        // remove existing label if any
        if (this.labelEntity) {
        this.el.removeChild(this.labelEntity);
        }
        
        if (!this.data.text) return;
        
        // create label entity
        this.labelEntity = document.createElement('a-entity');
        this.labelEntity.setAttribute('text', {
        value: this.data.text,
        color: this.data.color,
        width: 2,
        align: 'center',
        anchor: 'center'
        });
        
        // position above obj
        this.labelEntity.setAttribute('position', `0 ${this.data.yOffset} 0`);
        
        // make label always face camera
        this.labelEntity.setAttribute('look-at', '#camera');
        
        // add to parent entity
        this.el.appendChild(this.labelEntity);
    }
    });

    // label creation
  document.addEventListener('DOMContentLoaded', function() {
    // setup label submission
    const submitLabel = function() {
      const labelUI = document.querySelector('#label-ui');
      const labelInput = document.querySelector('#label-input');
      
      if (!labelUI || !labelInput) return;
      
      const objectId = labelUI.dataset.objectId;
      const labelText = labelInput.value.trim();
      
      if (objectId && labelText) {
        // get obj and add label
        const object = document.getElementById(objectId);
        if (object) {
          object.setAttribute('object-label', {text: labelText});
          console.log(`Set label "${labelText}" on object ${objectId}`);
          
          // mark this object as labeled
          const plate = document.querySelector('[plate-interaction]');
          if (plate && plate.components['plate-interaction']) {
            plate.components['plate-interaction'].objectsLabeled[objectId] = true;
          }
        }
      }
      
      // hide ui
      labelUI.style.display = 'none';
    };

    // submit label
    const submitButton = document.querySelector('#submit-label');
    if (submitButton) {
      submitButton.addEventListener('click', submitLabel);
    }
    
    // cancel label
    const cancelButton = document.querySelector('#cancel-label');
    if (cancelButton) {
      cancelButton.addEventListener('click', function() {
        // hide gallery naming
        document.querySelector('#label-ui').style.display = 'none';
      });
    }
    
    // enter label
    const labelInput = document.querySelector('#label-input');
    if (labelInput) {
      labelInput.addEventListener('keyup', function(event) {
        if (event.key === 'Enter') {
          submitLabel();
        }
      });
    }

    // upload btn
    const uploadBtn = document.getElementById('upload-btn');
      if (uploadBtn) {
          uploadBtn.addEventListener('click', function() {
          // opens files on click
          document.getElementById('file-input').click();
        });
      }

    // file upload
    const fileInput = document.getElementById('file-input');
      if (fileInput) {
        fileInput.addEventListener('change', function(e) {
          const file = e.target.files[0];
            if (file) {
              alert('File "' + file.name + '", uploading..');
              // hide upload UI after upload
              document.getElementById('upload-ui').style.display = 'none';
          }
      });
    }

    const closeBtn = document.getElementById('close-btn');
      if (closeBtn) {
        closeBtn.addEventListener('click', function() {
        document.getElementById('upload-ui').style.display = 'none';
        });
      }
  });

    // bugs on the pedestal interaction
      AFRAME.registerComponent('pedestal-interaction', {
          init: function() {
              const self = this;
              this.hasDisplayedOwl = false;
              this.pedestalTop = new THREE.Vector3();
              
              
              if (!self.el.classList.contains('interactive')) {
                  self.el.classList.add('interactive');
              }

              // calc top center of pedestal
              this.updatePedestalPosition = () => {
                  this.el.object3D.getWorldPosition(this.pedestalTop);
                  this.pedestalTop.y += 1.5; // adjustable based on height
              };

              this.el.addEventListener('click', () => {
                console.log('Pedestal clicked');
                  const manager = this.el.sceneEl.components['interaction-manager'];
                  const heldId = manager.pickedUpObject;
                  const owlEntity = document.querySelector('#owl');
                  const uploadUI = document.querySelector('#upload-ui');
                  
                  // when clicked show upload UI
                  if (uploadUI) {
                    console.log('Showing Upload UI');
                      uploadUI.style.display = 'block';
                  } else {
                      console.error("Upload component not found...");
                  }

                  if (!owlEntity) return;

                  this.updatePedestalPosition();

                  if (heldId === 'owl' && !this.hasDisplayedOwl) {
                      console.log('placing owl on pedestal...');
                      this.hasDisplayedOwl = true;

                      // detach owl from camera to place in scene
                      owlEntity.sceneEl.object3D.attach(owlEntity.object3D);
                      
                      // setting owl world postiion to top of pedestal
                      owlEntity.setAttribute('position', {
                          x: this.pedestalTop.x,
                          y: this.pedestalTop.y,
                          z: this.pedestalTop.z
                      });
                      owlEntity.setAttribute('rotation', '0 0 0');
                      owlEntity.setAttribute('scale', '1 1 1');
                      owlEntity.setAttribute('visible', true);
                      
                      // update pickup state
                      owlEntity.components.pickupable.pickedUp = false;
                      manager.pickedUpObject = null;

                      console.log('Owl placed at position:', owlEntity.getAttribute('position'));
                  } 
                  else if (this.hasDisplayedOwl && !manager.pickedUpObject) {
                      console.log('retrieving owl from pedestal');
                      this.hasDisplayedOwl = false;

                      const camera = document.querySelector('#camera');
                      
                      // attach owl to camera for pickup
                      camera.object3D.attach(owlEntity.object3D);
                      
                      // update pos relative to camera
                      owlEntity.setAttribute('position', {
                          x: 0,
                          y: -0.5, // slightly below
                          z: -1    // infront
                      });
                      
                      owlEntity.components.pickupable.pickedUp = true;
                      manager.pickedUpObject = 'owl';
                  }
              });

              // Initial position update
              this.updatePedestalPosition();
          }
      });

      // interaction manager - listens for entities being picked up/released globally
      AFRAME.registerComponent('interaction-manager', {
  init: function() {
    const self = this;
    self.pickedUpObject = null;
    
    self.el.sceneEl.addEventListener('object-picked-up', (e) => {
      self.pickedUpObject = e.detail.id;
      console.log('interaction-manager: picked up:', self.pickedUpObject);
    });

    self.el.sceneEl.addEventListener('object-released', (e) => {
      self.pickedUpObject = null;
      console.log('interaction-manager: nothing in hand');
    });
  }
});

  </script>
</head>

<body>
  <!-- this is used to create our enter UI that creates a 2D overlay to capture a user gesture for sound/mic access etc. -->
  <circles-start-ui/>

  <!-- Upload UI -->
  <div id="upload-ui">
    <span id="close-btn">&times;</span>
    <div class="center">
        <h2 style="color: white;">Upload a Keepsake</h2>
        <p style="color: white;">Acceptable file types 3D:.glb, .gltf</p>
        <button id="upload-btn">Choose File</button>
        <input type="file" id="file-input" style="display: none" accept=".glb,.gltf">
    </div>
</div>

    <!-- Orb Label UI-->
<div id="label-ui">
    <span id="close-label-btn">&times;</span>
    <div class="label-content">
      <h2>Name Your Orb</h2>
      <input type="text" id="label-input" placeholder="Enter a name...">
    </div>
    <div class="label-buttons">
      <button id="cancel-label" class="label-btn">Cancel</button>
      <button id="submit-label" class="label-btn">Submit</button>
    </div>
  </div>

  <!-- a-scene with 'circles-properties' component [REQUIRED] -->
  <a-scene circles_scene_properties interaction-manager background="color: black">
    <a-assets>
      <!-- put all assets here -->
      <!-- pedestal -->
      <a-asset-item id="pedestal-model" src="assets/models/doric_twist_pedestal.glb" response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      
      <!-- orb room model -->
      <a-asset-item id="orb-room-model" src="assets/models/Orb_Room.glb" response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      
      <!-- polycam scans -->
      <a-asset-item id="owl-model" src="assets/models/Owl Puppet (1).glb" response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>

      <!-- Circles' built-in assets [REQUIRED] -->
      <circles-assets/>
    </a-assets>

    <!-- Circles' built-in manager and avatar [REQUIRED] -->
    <circles-manager-avatar/>
  
    <!-- put scene stuff here -->
        <!-- camera -->
        <a-entity 
        id="camera" 
        camera 
        look-controls 
        wasd-controls 
        twoway-motion="speed: 35"
        position="0 1.6 0" 
        cursor="rayOrigin: mouse"
        circles-interactive-object
        raycaster="objects: .interactive; far: 20; interval: 100">
        </a-entity>

        <!-- pedestal -->
        <a-entity
        id="pedestal"
        class="interactive"
        position="2.3 0 0"
        rotation="0 90 0"
        scale="2 2 2"
        gltf-model="#pedestal-model"
        pedestal-interaction
        circles-interactive-object
        shadow="cast:true; recieve:true;">
        </a-entity>

        <!-- owl -->
        <a-entity
        id="owl"
        circles-pickup-object="
        
        "
        circles-interactive-object
        position="0 0 0"
        rotation="0 0 0"
        scale="1 1 1"
        gltf-model="#owl-model"
        shadow="cast:true; receive:true"
        visible="true">
        </a-entity>

      <a-sphere id="pickupSphere"
        position="0 1 -2"
        radius="0.2"
        material="color: #3498db; metalness: 0.7; roughness: 0.3"
        circles-interactive-object
        pickupable
        object-label="text: ; yOffset: 0.4">
      </a-sphere>

        <!-- plate -->
        <a-cylinder id="plate"
        position="1 0.05 -2"
        height="0.1"
        radius="0.5"
        material="color: #e74c3c"
        circles-interactive-object
        plate-interaction
        class="interactive">
        </a-cylinder>

        <!-- testing orb room model -->
        <!--<a-entity
        id="orb-room"
        position="0 0 0"
        rotation="0 0 0"
        scale="30 30 30"
        gltf-model="#orb-room-model"
        shadow="recieve:true;">
        </a-entity>-->

  </a-scene>

  <!-- Circles' end scripts [REQUIRED] -->
  <circles-end-scripts/>
 </body>
</html>